OPERATOR OVERLOADING:-
	A feature that facilitates the programmer to enhancing or overcome the limitation's of the standard operators, which are primarily designed to only work on standard or primitive types, to also work on user-defined types (class objects).


int a,b,c;
c = a+b;

CA obj1, obj2, obj2;

obj3 = obj1 + obj2;  //error
------------------------------------------------
Assignment operator overloading:-

CA obj1, obj2;
obj2 = obj1;   //assignment, compiler is expected to generate an assignment function.

	- If there is any assignment of class objects, and incidentally in such a class if no custom assignment function is provided, then the compiler is expected to generate one.
	- The compiler generated assignment function is also called - member-to-member assignment or bit-wise assignment.
	- This method generated by the compiler would be automatically inlined.

		obj2.a = obj1.a
                obj2.b = obj1.b
                //..

----------------------------------------
UNARY OPERATORS:-
	These are operators that work on a single operand. For eg:-   ++  --  &  *

int a=10;
int b;

PREFIX

b = ++a;     a=11   b=11

POSTFIX

b = a++;     a=11  b=10

----------

class CA
{
public: 
  CA operator ++();       //prefix
  CA operator ++(int);   //postfix
};

++obj1;   // obj1.operator ++();
obj1++;   // obj1.operator ++(int);
-----------------------------------------------------------------------
STREAM OPERATOR OVERLOADING:-

int a;
cin >> a;       // cin.operator >>(a);

	'cin' is a global object of ISTREAM class, and 'operator >>' is a member function of ISTREAM class.

class istream
{
public:
  istream& operator >>(int);
  istream& operator >>(float);
  //etc.. for all standard types...
};



cout << a;    // cout.operator <<(a);

	'cout' is a global object of OSTREAM class, and 'operator <<' is a member function of OSTREAM class.


class ostream
{
public:
  ostream& operator <<(int);
  ostream& operator <<(float);
  //etc.. for all standard types...
};


*******************************
CA obj1;
cin >> obj1;    // cin.operator >>(obj1);    --> ERROR, as their no suitable class member function
cout << obj1;   // cout.operator <<(obj1);   --> ERROR, as their no suitable class member function


OPERATOR + AS CLASS MEMBER

class CA
{
public:
  //..
  CA operator +(CA &x);
};

obj3 = obj1 + obj2;   // obj3 = obj1.operator +(obj2);

*********************

OPERATOR + AS GLOBAL FUNCTION

class CA
{
public:
  //...
};

//global function
CA operator +(CA &x1, CA &x2){...}

obj3 = obj1 + obj2;     // obj3 = operator +(obj1, obj2);
-------------------------------------
If not for suitable class member, atleast a suitable global

CA obj1;
cin >> obj1;    // operator >>(cin, obj1);   --> operator >>(istream& input, CA& ob);
cout << obj1;   // operator <<(cout, obj1);  --> operator <<(ostream& print, CA& ob);
---------------------------------------------------------
CONVERSION FUNCTIONS:-
	These are member functions, which take 'data-type' as their names.


class CA
{
private:
  //...
public:
  CA();
  explicit CA(int);
  //...
  void operator =(int x) {...}
  //..
  operator int();
};


//****consumer*****

void main()
{
  CA obj1;
  int x = 100;

  obj1 = x;        // obj1 = CA(x)  --> conversion will fail, as one arg. constructor is 'explicit'
  obj1 = x;        // ob1.operator =(x);

  x = obj1;
  
}
------------------------------------------------------------
DYNAMIC MEMORY ALLOCATION:-
	Making our code or program to smartly manage memory as per the end-user's requirement.


   C              C++
malloc         new, new(nothrow)
calloc         new[]
realloc        --
free           delete, delete[]

	       Placement new operator
-------------------------------------------

Suggestion:
	- Prefer malloc/free function pairs when we wish to store standard type data or C structs. They are more
          efficient when compared to new/delete

	- Prefer new/delete function pairs when we wish to store class objects. As 'new' is capable of implicitly
          invoking appropriate constructor method and 'delete' is capable of calling the destructor method.
		
	
//throw version

CA* p = new CA;     // CA* p = (CA*) operator new(sizeof(CA));
                       p->CA::CA();


	The form of the operator new function...

		void* operator new(size_t size)        //size_t  ==> unsigned int
                {
                    //if allocation successfull...
                            return address..
                    //else
                            throw bad_alloc();
                }


//nothrow version

CA* p = new=(nothrow) CA;     // CA* p = (CA*) operator new(sizeof(CA), nothrow());
                                 p->CA::CA();


	The form of nothrow new operator function....

struct nothrow{ };  //empty struct, just to facilitate overloading...

	void* operator new(size_t size, nothrow &x)
        {
             //if allocation successful
                    return address;
             //else
                     return NULL;
        }

---------------------------------------

CA* p = new(nothrow) CA[5];

p[0].print();
//..


If we create an array of objects on the stack

CA p[5];

p[0].print();

---------------------------------

class CB
{
private:
  CA* p;
public:
  //...
  //...
  CA* GetCAaddress()
  {
    return p;
  }
  CA* operator &()
  {
    return p;
  }
  CA* operator ->()
  {
    return p;
  }
  CA& operator *()
  {
     return *p;
  }
};

//*****consumer *****
void main()
{
  CB obj1;
  CA* q = obj1.p;  //ERROR, cannot access private member

  CA* q = obj1.GetCAaddress();
  
  CA* q = &obj1;    // CA* q = obj1.operator &();
  
  obj1->print();

  (*obj1).print();   // (obj1.operator *()).print();
  return 0;
}
*****************************************************

There are a few operators that cannot be overloaded

	.     dot operator
	::    scope-resolution operator
	.*    dot-star operator
	?:    conditional operator
	sizeof

---------------------------------------------------------------
FUNCTION POINTERS:-
	These are pointer variables, capable of holding the address of functions residing on the code-segment.



void Add(int x, int y){...}
void Diff(int x, int y){...}
//...


void(*fp)(int, int);
//..
fp = &Add;
(*fp)(10,20);   // Add(10,20);
**************************

void(*fp1)(int, int) = &Diff;
(*fp1)(40,20);    //Diff(40,20);
*********************************

void(*fp2)();   //pointer to a global function of the form return-type void and input void

int(*fp3)();    //pointer to a global function of the form return-type 'int' and input is void.

char(*fp4)(char, int);  //pointer to a global function of the form return-type is 'char' and input is 2 param's of type
                           'char' & 'int' respectively.

-----------------------------------------
PLACEMENT NEW:-

	The placement new, which is an overloaded version of the standard new operator, helps developers to ensure that every allocation request is honoured and never turned down. Further, also ensures, that every instance allocated on the heap is physically adjacent to the previous.
	Useful under circumstances when we to store small objects.

Note: Allocating memory in the traditional style, using the standard new operator for small objects can eat up a lot of heap memory un-necessarily, which can be now avoided with the help of placement new operator.
-------------------------------------------------------------
FUNCTION OBJECTS AND FUNCTORS:-

	Function objects: Objects of a class which encapsulates a handle to another function, in order to facilitate a call-back.

	Functor(s):- Overloading of function operator [ () ] is actually called FUNCTOR.

------------------------------
GENERIC CLASSES (or) CLASS TEMPLATES:-

template<typename T> class CA   //one or more data members of the class can be of type 'T' (GENERIC type)
{
private:
     T a,b;
public:
     CA(T);
     CA(T, T);
     ~CA();
     void Sum();
};

template<typename T> CA<T>::CA(T x):a(x),b(x)
{...}


template<typename T> void CA<T>::Sum(){...}

//****consumer***
CA obj1;//ERROR

CA<int> obj1;     //ok
CA<float> obj2;   
--------------------------------------------------------------------

template<typename T> class CA   
{
private:
    T arr[10];
public:
  //...
};

/*
    - The above generic class only provides flexilibility in deciding data-type of the elements in the array and not
      the size of the array

*/


//****consumer code****

CA<int> obj1;       ==>  int arr[10];
CA<float obj2;      ==> float arr[10];

----------------------------------------------------------------------
Let us make use of NON-TYPE parameters in the generic class, so as to provide a greater degree of flexibility
to the class consumer, so that they can also decide the size of the array apart from its data-type.


template<int SIZE, typename T> class CA   
{
private:
    T arr[SIZE];
public:
  //...
};

//****consumer code****

CA<10,int> obj1;       ==>  int arr[10];
CA<20, float> obj2;      ==> float arr[20];

----------------------------------------------------------------